#### 1. Set-up ####
# Set plotting theme
theme_set(theme_classic())
# Graphical parameters
island_colors <- brewer.pal(8, "Set2")
island_colors <- c(island_colors, "darkgreen")
habitat_colors <- c("goldenrod", "forestgreen", "mediumseagreen")
# Global settings
pc_names <- paste0("PC", 1:4)
wpc_names <- paste0("w", pc_names)
wl <- 300:700
wl_names <- paste0("wl", wl)
# Whether to load machines already fitted to whole spectrum data
# (instead of rerunning the very lengthy classification)
read_fitted <- TRUE
#### 2. Read reflectance data ####
# Read the data
D <- read_csv("data/reflectance.csv")
# Useful things to keep in mind
island_names <- unique(D$island)
habitat_names <- unique(D$habitat)
# Save sample sizes
with(D, table(island, habitat)) %>%
as_tibble() %>%
pivot_wider(names_from = habitat, values_from = n) %>%
write_csv("metadata/counts.csv")
#### 3. Principal component analysis ####
# Perform a PCA first because wavelengths are highly correlated
PCA <- prcomp(D[, wl_names], center = TRUE, scale = TRUE)
# How many PCs to retain?
cumsum(PCA$sdev / sum(PCA$sdev))
# Retain explained variance
expvars <- PCA$sdev[1:4] / sum(PCA$sdev)
# With four PCs we explain more than 90% of the variance
PCs <- PCA$x[, 1:4]
# Scale the principal components to unit variance (they are centered by constr)
PCs <- scale(PCs, scale = TRUE)
# Attach the matrix of principal components to the dataset
D <- cbind(D, PCs)
#### 6. Within-island principal component analysis ####
# Perform PCA within each island
D <- D %>%
group_by(island) %>%
nest() %>%
mutate(
# Within-island principal component analysis
PCA = map(data, ~ prcomp(.x[, wl_names], center = TRUE, scale = TRUE)),
# Extract rotated data
PCs = map(PCA, function(PCA) {
PCs <- as_tibble(scale(PCA$x[, 1:4], scale = TRUE))
colnames(PCs) <- paste0("w", colnames(PCs)) # label to recognize them
return(PCs)
})
)
# Extract the fitted within-island PCAs
wPCA <- D$PCA
names(wPCA) <- island_names
# Unnest the data frame
D <- D %>%
select(-PCA) %>%
unnest(cols = c(data, PCs))
# Now the dataset is complete
# saveRDS(D, "data.rds")
# Set specific colors for the retained PCs
wpc_colors <- hue_pal()(length(wpc_names))
names(wpc_colors) <- str_remove(wpc_names, "w")
#### 6.4. Explained variance ####
# Make a table with the variance explained by each PC on each island
map(wPCA, ~ with(.x, sdev[1:4] / sum(sdev))) %>%
do.call("rbind", .) %>%
as_tibble(.name_repair = ) %>%
mutate(expvar = rowSums(.)) %>%
mutate(island = island_names) %>%
setNames(c(pc_names, "expvar", "island")) %>%
select(island, expvar, pc_names) %>%
write_csv("results/pc_expvars/pc_expvars.csv")
# Make a table with the variance explained by each PC on each island
map(wPCA, ~ with(.x, sdev[1:4] / sum(sdev))) %>%
do.call("rbind", .) %>%
as_tibble(.name_repair = ) %>%
mutate(expvar = rowSums(.)) %>%
mutate(island = island_names) %>%
setNames(c(pc_names, "expvar", "island")) %>%
select(island, expvar, pc_names) #%>%
PCA
PCA$sdev
PCA$sdev[1:4]
PCA$sdev %>% .[1:4]
PCA$sdev %>% .[1:4] / sum(.)
PCA$sdev %>% (.[1:4] / sum(.))
PCA$sdev %>% {.[1:4] / sum(.)}
with(PCA, sdev[1:4] / sum(sdev))
# Make a table with the variance explained by each PC on each island
map(wPCA, ~ with(.x, sdev[1:4] / sum(sdev))) %>%
do.call("rbind", .) %>%
as_tibble(.name_repair = ) %>%
mutate(expvar = rowSums(.)) %>%
mutate(island = island_names) %>%
setNames(c(pc_names, "expvar", "island")) %>%
select(island, expvar, pc_names) #%>%
pc_expvar <- with(PCA, sdev[1:4] / sum(sdev))
pc_expvar <- with(PCA, sdev[1:4] / sum(sdev))
names(pc_expvar) <- pc_names
pc_expvar
as.list(pc_expvar)
c(island = "All islands", expvar = sum(pc_expvar), as.list(pc_expvars))
c(island = "All islands", expvar = sum(pc_expvar), as.list(pc_expvar))
X %>% add_row(island)
# Make a table with the variance explained by each PC on each island
X <- map(wPCA, ~ with(.x, sdev[1:4] / sum(sdev))) %>%
do.call("rbind", .) %>%
as_tibble(.name_repair = ) %>%
mutate(expvar = rowSums(.)) %>%
mutate(island = island_names) %>%
setNames(c(pc_names, "expvar", "island")) %>%
select(island, expvar, pc_names)
new_row <- c(island = "All islands", expvar = sum(pc_expvar), as.list(pc_expvar))
X %>% add_row(!!!new_row)
# Make a table with the variance explained by each PC on each island
X <- map(wPCA, ~ with(.x, sdev[1:4] / sum(sdev))) %>%
do.call("rbind", .) %>%
as_tibble(.name_repair = ) %>%
mutate(expvar = rowSums(.)) %>%
mutate(island = island_names) %>%
setNames(c(pc_names, "expvar", "island")) %>%
select(island, expvar, pc_names)
# Record explained variance for the global PCA on all islands
pc_expvar <- with(PCA, sdev[1:4] / sum(sdev))
names(pc_expvar) <- pc_names
# Prepare extra row for all islands
new_row <- c(
island = "All islands",
expvar = sum(pc_expvar),
as.list(pc_expvar)
)
# Append extra row
X <- X %>% add_row(!!!new_row)
# Save the table
write_csv("results/pc_expvars/pc_expvars.csv")
X
# Save the table
write_csv(X, "results/pc_expvars/pc_expvars.csv")
rm(list = ls())
library(tidyverse)
library(knitr)
library(kableExtra)
rm(list = ls())
library(tidyverse)
library(knitr)
library(kableExtra)
#### 0. Accessory functions ####
# Function to add a significance column with asterisk symbols to a tibble
mutate_signif <- function(
D, col = "pvalue", levels = c(0.05, 0.01, 0.001), dropname = TRUE
) {
D <- D %>%
mutate(
.signif = ifelse(get(col) < levels[1], "*", ""),
.signif = ifelse(get(col) < levels[2], "**", .signif),
.signif = ifelse(get(col) < levels[3], "***", .signif)
)
if (dropname) D <- D %>% rename(" " = ".signif")
return(D)
}
# Round and format P-values
round_pvalue <- function(pvalue, digits = 4) {
threshold <- 1 / 10^digits
template <- paste0("%.", sprintf("%sf", digits))
label <- sprintf(paste("<", template), threshold, digits)
rounded <- sprintf(template, round(pvalue, digits), digits)
ifelse(pvalue < threshold, label, rounded)
}
# PCA explained variance
read_csv("results/pc_expvars/pc_expvars.csv") %>%
kable(
"latex",
col.names = c(
"Island", "Total", paste0("PC", 1:4)
),
digits = c(0, 3, 3, 3, 3, 3),
booktabs = TRUE,
linesep = ""
) %>%
cat(file = "ms/tables/pcavariances.tex")
read_csv("results/pc_expvars/pc_expvars.csv") %>%
kable(
"latex",
col.names = c(
"Island", "Total", paste0("PC", 1:4)
),
digits = c(0, 3, 3, 3, 3, 3),
booktabs = TRUE,
linesep = ""
)
rm(list = ls())
library(nmgc)
library(tidyverse)
library(ggridges)
library(ggiraphExtra)
library(broom)
library(heplots)
library(MVN)
library(assertthat)
library(rminer)
library(geosphere)
library(MuMIn)
library(nlme)
library(PMCMRplus)
library(RColorBrewer)
library(pairwiseAdonis)
library(scales)
library(vegan)
# Set plotting theme
theme_set(theme_classic())
# Graphical parameters
island_colors <- brewer.pal(8, "Set2")
island_colors <- c(island_colors, "darkgreen")
habitat_colors <- c("goldenrod", "forestgreen", "mediumseagreen")
# Global settings
pc_names <- paste0("PC", 1:4)
wpc_names <- paste0("w", pc_names)
wl <- 300:700
wl_names <- paste0("wl", wl)
# Whether to load machines already fitted to whole spectrum data
# (instead of rerunning the very lengthy classification)
read_fitted <- TRUE
# Read the data
D <- read_csv("data/reflectance.csv")
# Useful things to keep in mind
island_names <- unique(D$island)
habitat_names <- unique(D$habitat)
# Perform a PCA first because wavelengths are highly correlated
PCA <- prcomp(D[, wl_names], center = TRUE, scale = TRUE)
# How many PCs to retain?
cumsum(PCA$sdev / sum(PCA$sdev))
# Retain explained variance
expvars <- PCA$sdev[1:4] / sum(PCA$sdev)
# With four PCs we explain more than 90% of the variance
PCs <- PCA$x[, 1:4]
# Scale the principal components to unit variance (they are centered by constr)
PCs <- scale(PCs, scale = TRUE)
# Attach the matrix of principal components to the dataset
D <- cbind(D, PCs)
# Perform PCA within each island
D <- D %>%
group_by(island) %>%
nest() %>%
mutate(
# Within-island principal component analysis
PCA = map(data, ~ prcomp(.x[, wl_names], center = TRUE, scale = TRUE)),
# Extract rotated data
PCs = map(PCA, function(PCA) {
PCs <- as_tibble(scale(PCA$x[, 1:4], scale = TRUE))
colnames(PCs) <- paste0("w", colnames(PCs)) # label to recognize them
return(PCs)
})
)
# Extract the fitted within-island PCAs
wPCA <- D$PCA
names(wPCA) <- island_names
# Unnest the data frame
D <- D %>%
select(-PCA) %>%
unnest(cols = c(data, PCs))
# Now the dataset is complete
# saveRDS(D, "data.rds")
# Set specific colors for the retained PCs
wpc_colors <- hue_pal()(length(wpc_names))
names(wpc_colors) <- str_remove(wpc_names, "w")
# Save site metadata
D %>%
group_by(island, longitude, latitude, habitat) %>%
summarize(across(wpc_names, mean)) %>%
write_csv("metadata/sites.csv")
set.seed(1994)
library(ape)
?Moran.I
tr <- rtree(30)
x <- rnorm(30)
## weights w[i,j] = 1/d[i,j]:
w <- 1/cophenetic(tr)
## set the diagonal w[i,i] = 0 (instead of Inf...):
diag(w) <- 0
Moran.I(x, w)
w
?cophenetic
D[D$island == "Abaco"]
D[D$island == "Abaco",]
?mantel
D %>%
group_by(island) %>%
nest() %>%
mutate(
# Get a vector of observed and permuted correlation coefficients
mantel_test = map(data, function(X) {
# Compute mean phenotypes per site
S <- X %>%
group_by(longitude, latitude) %>%
nest() %>%
mutate(
data = map(data, function(data) {
tibble(
variable = wpc_names,
mean = colMeans(data[wpc_names])
)
})
) %>%
unnest(cols = c(data)) %>%
pivot_wider(names_from = "variable", values_from = "mean")
# Matrix of geographic distances between sites
G <- as.dist(
distm(
S[c("longitude", "latitude")], fun = distGeo
)
)
# Matrix of euclidean distances between site means in phenotype space
M <- dist(S[wpc_names])
# Mantel's test of correlation between these two matrices
test_result <- mantel(G, M, permutations = 1000)
test_stat <- test_result$statistic
p_value <- test_result$signif
return(list(test_stat, p_value))
}),
# Extract the test statistics
mantel = map_dbl(mantel_test, ~ .x[[1]]),
pvalue = map_dbl(mantel_test, ~ .x[[2]])
) %>%
select(mantel, pvalue)
D %>%
group_by(island) %>%
nest() %>%
mutate(
# Get a vector of observed and permuted correlation coefficients
mantel_test = map(data, function(X) {
# Compute mean phenotypes per site
S <- X %>%
group_by(longitude, latitude) %>%
nest() %>%
mutate(
data = map(data, function(data) {
tibble(
variable = wpc_names,
mean = colMeans(data[wpc_names])
)
})
) %>%
unnest(cols = c(data)) %>%
pivot_wider(names_from = "variable", values_from = "mean")
# Matrix of geographic distances between sites
G <- as.dist(
distm(
S[c("longitude", "latitude")], fun = distGeo
)
)
# Matrix of euclidean distances between site means in phenotype space
M <- dist(S[wpc_names])
# Mantel's test of correlation between these two matrices
test_result <- mantel(G, M)
test_stat <- test_result$statistic
p_value <- test_result$signif
return(list(test_stat, p_value))
}),
# Extract the test statistics
mantel = map_dbl(mantel_test, ~ .x[[1]]),
pvalue = map_dbl(mantel_test, ~ .x[[2]])
) %>%
select(mantel, pvalue)
D %>%
group_by(island) %>%
nest() %>%
mutate(
# Get a vector of observed and permuted correlation coefficients
mantel_test = map(data, function(X) {
# Compute mean phenotypes per site
S <- X %>%
group_by(longitude, latitude) %>%
nest() %>%
mutate(
data = map(data, function(data) {
tibble(
variable = wpc_names,
mean = colMeans(data[wpc_names])
)
})
) %>%
unnest(cols = c(data)) %>%
pivot_wider(names_from = "variable", values_from = "mean")
# Matrix of geographic distances between sites
G <- as.dist(
distm(
S[c("longitude", "latitude")], fun = distGeo
)
)
# Matrix of euclidean distances between site means in phenotype space
M <- dist(S[wpc_names])
# Mantel's test of correlation between these two matrices
test_result <- mantel(G, M)
test_stat <- test_result$statistic
p_value <- test_result$signif
return(list(test_stat, p_value))
}),
# Extract the test statistics
mantel = map_dbl(mantel_test, ~ .x[[1]]),
pvalue = map_dbl(mantel_test, ~ .x[[2]])
) %>%
select(mantel, pvalue) %>%
write_csv("results/spatial_correlation/mantel_test.csv")
set.seed(99)
D %>%
group_by(island) %>%
nest() %>%
mutate(
# Get a vector of observed and permuted correlation coefficients
mantel_test = map(data, function(X) {
# Compute mean phenotypes per site
S <- X %>%
group_by(longitude, latitude) %>%
nest() %>%
mutate(
data = map(data, function(data) {
tibble(
variable = wpc_names,
mean = colMeans(data[wpc_names])
)
})
) %>%
unnest(cols = c(data)) %>%
pivot_wider(names_from = "variable", values_from = "mean")
# Matrix of geographic distances between sites
G <- as.dist(
distm(
S[c("longitude", "latitude")], fun = distGeo
)
)
# Matrix of euclidean distances between site means in phenotype space
M <- dist(S[wpc_names])
# Mantel's test of correlation between these two matrices
test_result <- mantel(G, M)
test_stat <- test_result$statistic
p_value <- test_result$signif
return(list(test_stat, p_value))
}),
# Extract the test statistics
mantel = map_dbl(mantel_test, ~ .x[[1]]),
pvalue = map_dbl(mantel_test, ~ .x[[2]])
) %>%
select(mantel, pvalue) %>%
write_csv("results/spatial_correlation/mantel_test.csv")
rm(list = ls())
library(tidyverse)
library(knitr)
library(kableExtra)
#### 0. Accessory functions ####
# Function to add a significance column with asterisk symbols to a tibble
mutate_signif <- function(
D, col = "pvalue", levels = c(0.05, 0.01, 0.001), dropname = TRUE
) {
D <- D %>%
mutate(
.signif = ifelse(get(col) < levels[1], "*", ""),
.signif = ifelse(get(col) < levels[2], "**", .signif),
.signif = ifelse(get(col) < levels[3], "***", .signif)
)
if (dropname) D <- D %>% rename(" " = ".signif")
return(D)
}
# Round and format P-values
round_pvalue <- function(pvalue, digits = 4) {
threshold <- 1 / 10^digits
template <- paste0("%.", sprintf("%sf", digits))
label <- sprintf(paste("<", template), threshold, digits)
rounded <- sprintf(template, round(pvalue, digits), digits)
ifelse(pvalue < threshold, label, rounded)
}
# Mantel's test of spatial autocorrelation
read_csv("results/spatial_correlation/mantel_test.csv") %>%
mutate_signif() %>%
mutate(pvalue = round_pvalue(pvalue, digits = 3)) %>%
kable(
"latex",
col.names = c(
"Island", "$\\rho$", "$P$", ""
),
digits = c(0, 3, 0, 0),
align = "lrrl",
booktabs = TRUE,
linesep = "",
escape = FALSE
) %>%
cat(file = "ms/tables/mantel.tex")
read_csv("results/spatial_correlation/mantel_test.csv")
read_csv("results/spatial_correlation/mantel_test.csv") %>%
mutate_signif()
read_csv("results/spatial_correlation/mantel_test.csv") %>%
mutate_signif() %>%
mutate(pvalue = round_pvalue(pvalue, digits = 3))
read_csv("results/spatial_correlation/mantel_test.csv") %>%
mutate_signif() %>%
mutate(pvalue = round_pvalue(pvalue, digits = 3)) %>%
kable(
"latex",
col.names = c(
"Island", "$\\rho$", "$P$", ""
),
digits = c(0, 3, 0, 0),
align = "lrrl",
booktabs = TRUE,
linesep = "",
escape = FALSE
)
?mantel
?vegan
