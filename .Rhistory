data, variables, grouping = "habitat", random = "island", univariate = TRUE,
parametric = TRUE
)
?gather_
#' Nested ANOVA
#'
#' Performs (M)ANOVAs for multiple variables across different subsets of the data. Models fitted with OLS and GLS (allowing one independent residual variance per group) are compared with AIC and the best-fitting model is retained. Multiple post-hoc comparisons can be performed too.
#'
#' @param data A data frame
#' @param variables The variables to analyze
#' @param nesting The name of the nesting factor
#' @param grouping The name of the grouping factor
#' @param posthoc Whether to perform post-hoc tests
#' @param to_pcomp Optional variables to perform PCA on
#' @param center,scale Parameters for `npcomp`
#' @param test Test to use for the MANOVA (defaults to Pillai's trace). See `?summary.manova`
#' @param univariate Whether to perform ANOVA (TRUE) or MANOVA (FALSE)
#' @param add_signif Whether to add significance asterisk labels in an extra column
#' @param parametric Whether to perform parametric tests (linear models instead of Kruskal-Wallis if `univariate` is TRUE, parametric instead of semi-parametric MANOVA if `univariate` is FALSE)
#' @param seed Optional seed for the semi-parametric MANOVA
#' @param iter Number of iterations for the parametric bootstrapping of the semi-parametric MANOVA (defaults to the recommended number 1,000)
#' @param random Optional random effect for fitting a mixed model in univariate ANOVA
#' @param pthreshold Threshold P-value to keep posthoc tests (set to 1 to keep all tests)
#'
#' @details The analysis of variance is performed using a likelihood ratio test between a model including the factor of interest and a null model with intercept only. The LRT is done with models fitted with maximum likelihood. Model comparison between OLS and GLS is done with models fitted with restricted maximum likelihood, that include the factor to be tested (as per Zuur et al. 2009).
#'
#' @note Note that `posthoc` will be set to FALSE automatically if `univariate` is FALSE. We do not do multivariate contrasts.
#'
#' @return A list with two objecst: `res`, containing the results of the variable-wise ANOVA tests, and `ph`, containing the results of the contrast-wise posthoc tests. `res` can be of multiple formats. If `manova` is FALSE, data frame containing the results of the ANOVAs for each variable and each subset of the data, including:
#'
#' \itemize{
##'  \item{best}{ The best-fitting model (OLS or GLS)}
##'  \item{df_model}{ Model degrees of freedom}
##'  \item{AICc}{ AICc of the model}
##'  \item{dAICc}{ Difference in AICc between the GLS-model and the OLS-model}
##'  \item{df_LRT}{ Degrees of freedom of the likelihood ratio test}
##'  \item{loglik}{ Log-likelihood of the full model in LRT}
##'  \item{lratio}{ Chi-square value i.e. likelihood ratio between the full and the null model in LRT}
##'  \item{pvalue}{ P-value of the LRT}
##'  \item{posthoc_test}{ Post-hoc test used: Wilcoxon or Tukey}
##'  \item{posthoc_p...}{ Extra columns with the P-values for each contrast in the multiple post-hoc comparisons}
##' }
#'
#' Otherwise, a data frame with MANOVA results for each subset, including, if `semiparametric` is FALSE,
#'
#' \itemize{
#' \item{df}{ The degrees of freedom of the MANOVA}
#' \item{"statistic's name"}{ One of the statistics defined in `summary.manova` (Pillai, Wilks, etc.)}
#' \item{num_df}{ Numerator degrees of freedom of the F-test}
#' \item{denom_df}{ Denominator degrees of freedom of the F-test}
#' \item{pseudoF}{ Approximate F-statistic}
#' \item{pvalue}{ P-value of the F-test}
#' }
#'
#' otherwise, the results of a semi-parametric MANOVA, with:
#'
#' \itemize{
#' \item{term}{ The term being tested, probably the grouping variable}
#' \item{MATS}{ The modified ANOVA-type statistic value}
#' \item{pvalue}{ P-value computed from the parametric bootstrap resampling}
#' }
#'
#' @export
nanova <- function(
data,
variables,
grouping,
nesting = NULL,
univariate = TRUE,
posthoc = TRUE,
to_pcomp = NULL,
center = TRUE,
scale = TRUE,
test = "Pillai",
add_signif = TRUE,
parametric = TRUE,
seed = NULL,
iter = 1000,
random = NULL,
pthreshold = 0.05
) {
library(tidyverse)
# Compute principal components if needed
if (!is.null(to_pcomp)) data <- data %>%
cbind(npcomp(
data, to_pcomp, center, scale, nesting, combine = TRUE,
reduce = variables
)$x %>% data.frame %>% dplyr::select(-nesting))
# Nested or unnested design
if (is.null(nesting)) {
data$nesting <- factor(1)
nesting <- "nesting"
} else data$nesting <- data[[nesting]]
# Special column for grouping
data$group <- data[, grouping]
# Variables must be named
names(variables) <- variables
# Choose the function to run
if (univariate) {
if (parametric) {
this_test <- function(x, y) nanova_anova(x, y, random = random)
} else {
this_test <- nanova_kruskal
}
} else {
if (parametric) {
this_test <- function(x, y) nanova_manova(x, y, test = test)
} else {
this_test <- function(x, y) nanova_smanova(x, y, seed = seed, iter = iter)
}
}
# Perform analysis on each subset
res <- data %>%
dplyr::group_by(nesting) %>%
tidyr::nest() %>%
dplyr::mutate(test = map(data, this_test, variables)) %>%
dplyr::select(-data) %>%
tidyr::unnest(cols = c(test))
# Add significance labels
if (add_signif) res <- res %>% add_signif()
if (!univariate) posthoc <- FALSE # we don't do multivariate posthoc tests around here
ph <- NULL
if (posthoc) {
# Choose what post-hoc test to perform
phtest <- res
if (parametric) {
phtest <- phtest %>% dplyr::mutate(test = ifelse(best_fit %% 2 == 0, "dunnett", "tukey"))
} else {
phtest <- phtest %>% dplyr::mutate(test = "nemenyi")
}
phtest <- phtest %>% dplyr::select(nesting, variable, pvalue, test)
# Perform posthoc tests
ph <- data %>%
tidyr::gather_("variable", "score", variables) %>%
dplyr::group_by(nesting, variable) %>%
tidyr::nest() %>%
dplyr::right_join(phtest) %>%
dplyr::mutate(posthoc = map2(data, test, nanova_posthoc)) %>%
dplyr::filter(pvalue < pthreshold) %>%
dplyr::select(-data, -pvalue) %>%
tidyr::unnest(cols = c(posthoc))
if (nrow(ph) > 0 & add_signif) ph <- ph %>% add_signif()
}
res <- list(res = res, ph = ph)
return (res)
}
# We run multiple ANOVAs despite non-normality. We also allow for
# islands to be treated as a random effect.
res_nanova <- nanova(
data, variables, grouping = "habitat", random = "island", univariate = TRUE,
parametric = TRUE
)
t1 <- res_nanova$res[, -1]
head(t1)
t1 <- res_nanova$res[, -1]
t1_fname <- "analyses/07-ANOVA/table_anova_pooled"
colnames <- c(
"Variable", "Best fit", "df", "AICc", "$\\Delta$AICc", "AICcw",
"df$_{\\mbox{LRT}}$", "Log-lik.", "$\\chi^2$", "$P$", ""
)
save_table(t1, t1_fname, digits = c(0, 0, 0, 1, 1, 3, 0, 1, 2, 4, 0), col.names = colnames)
t1_fname
colnames <- c(
"Variable", "Best fit", "df", "AICc", "$\\Delta$AICc", "AICcw",
"df$_{\\mbox{LRT}}$", "Log-lik.", "$\\chi^2$", "$P$", ""
)
save_table(t1, t1_fname, digits = c(0, 0, 0, 1, 1, 3, 0, 1, 2, 4, 0), col.names = colnames)
t1
?save_table
roxygen2::roxygenize()
library(dewlap)
?save_table
?kable
?knitr::kable
colnames
save_table(t1, t1_fname, digits = c(0, 0, 0, 1, 1, 3, 0, 1, 2, 4, 0), col.names = colnames)
t1_fname <- "analyses/06-pooled/table_anova_pooled"
colnames <- c(
"Variable", "Best fit", "df", "AICc", "$\\Delta$AICc", "AICcw",
"df$_{\\mbox{LRT}}$", "Log-lik.", "$\\chi^2$", "$P$", ""
)
save_table(t1, t1_fname, digits = c(0, 0, 0, 1, 1, 3, 0, 1, 2, 4, 0), col.names = colnames)
# Mixed models were always the best fit. They indicate significant differences,
# after accounting for the effect of islands, along PC1, 2 and 3
# But the differences are so small that posthoc tests could not identify what
# groups differ
t2 <- res_nanova$ph[, -1]
t2_fname <- "analyses/06-pooled/table_posthoc_pooled"
head(t2)
t2_fname <- "analyses/06-pooled/table_posthoc_pooled"
t2_names <- c("Variable", "Test", "Contrast", "", "Statistic", "$P$", "")
save_table(t2, t2_fname, digits = c(0, 0, 0, 0, 3, 4, 0), col.names = t2_names)
# We check with Kruskal-Wallis to account for non-normality, but then we
# cannot account for the effect of islands
res_kw <- nanova(
data, variables, grouping = "habitat", univariate = TRUE, parametric = FALSE
)
res_kw
t3 <- res_kw$res[, -1]
head(t3)
t3_fname <- "analyses/06-pooled/table_kw_pooled"
t3_names <- c("Variable", "$\\chi^2$", "df", "$P$", "")
save_table(t3, t3_fname, digits = c(0, 2, 0, 4, 0), col.names = t3_names)
t4 <- res_kw$ph[, -1]
t4
t4 <- res_kw$ph[, -1]
t4_fname <- "analyses/06-pooled/table_postkw_pooled"
t4_names <- c("Variable", "Test", "Contrast", "", "Statistic", "$P$", "")
save_table(t4, t4_fname, digits = c(0, 0, 0, 0, 2, 4, 0), col.names = t4_names)
rm(list = ls())
library(nmgc)
library(tidyverse)
library(cowplot)
library(knitr)
library(dewlap)
data <- read.csv("data/reflectance.csv", header = TRUE)
variables <- paste0("PC", 1:4)
wl <- paste0("wl", 300:700)
res_manova <- nanova(
data, variables, grouping = "habitat", nesting = "island", to_pcomp = wl,
univariate = FALSE, test = "Pillai"
)
res_manova$res # MANOVA table
res_smanova <- nanova(
data, variables, grouping = "habitat", nesting = "island", to_pcomp = wl,
univariate = FALSE, parametric = FALSE, seed = 42, iter = 1000
)
t1 <- res_smanova$res
head(t1)
t1 <- res_smanova$res
t1_fname <- "analyses/07-ANOVA/table_smanova"
t1_names <- c("Island", "MATS", "$P$", "")
save_table(t1, t1_fname, digits = c(0, 1, 4, 0), col.names = t1_names)
# Keep the most significant islands only (based on machine learning)
sislands <- c("Abaco", "Bimini", "Cayman Brac", "Little Cayman", "Long Island")
data <- data %>% filter(island %in% sislands) %>% droplevels
# Fit ANOVAs
res_anova <- nanova(
data, variables, grouping = "habitat", nesting = "island", to_pcomp = wl
)
devtools::install_github("rscherrer/nmgc")
library(nmgc)
# Fit ANOVAs
res_anova <- nanova(
data, variables, grouping = "habitat", nesting = "island", to_pcomp = wl
)
t2 <- res_anova$res
t2
head(t2)
t1
t2
t2 <- res_anova$res
t2_fname <- "analyses/07-ANOVA/table_anova"
t2_names <- c(
"Variable", "Best fit", "df", "AICc", "$\\Delta$AICc", "AICcw",
"df$_{\\mbox{LRT}}$", "Log-lik.", "$\\chi^2$", "$P$", ""
)
save_table(t2, t2_fname, digits = c(0, 0, 0, 0, 1, 1, 3, 0, 1, 2, 4, 0), col.names = t2_names)
library(dewlap)
save_table(t2, t2_fname, digits = c(0, 0, 0, 0, 1, 1, 3, 0, 1, 2, 4, 0), col.names = t2_names)
t2. <- res_anova$ph
t2
t2 <- res_anova$res
t2_fname <- "analyses/07-ANOVA/table_anova"
t2_names <- c(
"Variable", "Best fit", "df", "AICc", "$\\Delta$AICc", "AICcw",
"df$_{\\mbox{LRT}}$", "Log-lik.", "$\\chi^2$", "$P$", ""
)
save_table(t2, t2_fname, digits = c(0, 0, 0, 0, 1, 1, 3, 0, 1, 2, 4, 0), col.names = t2_names)
t2_fname
t2
?save_table
library(dewlap)
save_table(t2, t2_fname, digits = c(0, 0, 0, 0, 1, 1, 3, 0, 1, 2, 4, 0), col.names = t2_names)
head(t2)
t2_names <- c(
"Island", "Variable", "Best fit", "df", "AICc", "$\\Delta$AICc", "AICcw",
"df$_{\\mbox{LRT}}$", "Log-lik.", "$\\chi^2$", "$P$", ""
)
save_table(t2, t2_fname, digits = c(0, 0, 0, 0, 1, 1, 3, 0, 1, 2, 4, 0), col.names = t2_names)
t2. <- res_anova$ph
t2.
t2. <- res_anova$ph
t2._fname <- "analyses/07-ANOVA/table_posthoc"
t2._names <- c("Island", "Variable", "Test", "Contrast", "", "Statistic", "$P$", "")
save_table(t2., t2._fname, digits = c(0, 0, 0, 0, 0, 2, 4, 0), col.names = t2._names)
# We know that univariate normality is violated in some cases
norm <- read.csv("analyses/05-assumptions/table_normality.csv", header = TRUE)
norm %>% filter(pvalue < 0.05)
# Perform KW tests and record tests of univariate normality (for later)
res_kw <- nanova(
data, variables, grouping = "habitat", nesting = "island", to_pcomp = wl,
parametric = FALSE
)
norm2 <- norm %>%
group_by(island, variable) %>%
summarize(dev = any(pvalue < 0.05))
t3 <- res_kw$res %>%
rename(island = "nesting") %>%
right_join(norm2) %>%
filter(dev) %>%
select(-dev) %>%
drop_na()
head(t3)
t3_fname <- "analyses/07-ANOVA/table_kw"
t3_names <- c("Island", "Variable", "$\\chi^2$", "df", "$P$", "")
save_table(t3, t3_fname, digits = c(0, 0, 2, 0, 4, 0), col.names = t3_names)
t3. <- res_kw$ph %>%
rename(island = "nesting") %>%
right_join(norm2) %>%
filter(dev) %>%
select(-dev) %>%
drop_na()
head(t3.)
t3._fname <- "analyses/07-ANOVA/table_postkw"
t3._names <- c("Island", "Variable", "Test", "Contrast", "", "Statistic", "$P$", "")
save_table(t3., t3._fname, digits = c(0, 0, 0, 0, 0, 2, 4, 0), col.names = t3._names)
# Prepare PCA data for plotting
pca <- npcomp(data, wl, nesting = "island", combine = TRUE, reduce = 1:4)
pcdata <- pca$x
rotation <- pca$rotation
data <- cbind(data, pcdata[, variables])
data <- data %>% gather_("variable", "score", variables)
rm(list = ls())
library(tidyverse)
library(nmgc)
data <- read.csv("data/reflectance.csv", header = TRUE)
# Spatial autocorrelation test
res_cortest <- nspcortest(
data, variables = paste0("PC", 1:4), nesting = "island", nperm = 1000, seed = 42,
to_pcomp = paste0("wl", 300:400), keep = "habitat"
)
# Save table
t1 <- res_cortest$res
t1 <- t1 %>% add_signif()
t1
t1_fname <- "analyses/08-spatial correlation/table_spatial"
t1_names <- c("Island", "$r^2$", "$P$", "N", "")
save_table(t1, t1_fname, digits = c(0, 3, 3, 0), col.names = t1_names)
# Table with multivariate means per site
t2 <- res_cortest$sites
head(t2)
# Table with multivariate means per site
t2 <- res_cortest$sites
t2_fname <- "analyses/08-spatial correlation/table_spatial"
t2_names <- c("Island", "Longitude", "Latitude", "Habitat", "PC1", "PC2", "PC3", "PC4")
save_table(t2, t2_fname, digits = c(0, 4, 4, 0, 4, 4, 4, 4), col.names = t2_names)
# Save table
t1 <- res_cortest$res
t1 <- t1 %>% add_signif()
t1_fname <- "analyses/08-spatial correlation/table_spatial"
t1_names <- c("Island", "$r^2$", "$P$", "N", "")
save_table(t1, t1_fname, digits = c(0, 3, 3, 0), col.names = t1_names)
# Table with multivariate means per site
t2 <- res_cortest$sites
t2_fname <- "analyses/08-spatial correlation/table_sites"
t2_names <- c("Island", "Longitude", "Latitude", "Habitat", "PC1", "PC2", "PC3", "PC4")
save_table(t2, t2_fname, digits = c(0, 4, 4, 0, 4, 4, 4, 4), col.names = t2_names)
rm(list = ls())
library(tidyverse)
library(nmgc)
data <- read.csv("data/reflectance.csv", header = TRUE)
wl <- paste0("wl", 300:700)
variables <- paste0("PC", 1:4)
data <- cbind(data, npcomp(data, wl, nesting = "island", reduce = 1:4)$x)
# Kepp only the most significant islands
keep <- c("Abaco", "Bimini", "Cayman Brac", "Little Cayman", "Long Island")
data <- data %>% filter(island %in% keep)
data <- read.csv("data/reflectance.csv", header = TRUE)
wl <- paste0("wl", 300:700)
variables <- paste0("PC", 1:4)
data <- cbind(data, npcomp(data, wl, nesting = "island", reduce = 1:4)$x)
# Kepp only the most significant islands
keep <- c("Abaco", "Bimini", "Cayman Brac", "Little Cayman", "Long Island")
data <- data %>% filter(island %in% keep)
data <- data[, -grep("island", colnames(data))[2]]
# Kepp only the most significant islands
keep <- c("Abaco", "Bimini", "Cayman Brac", "Little Cayman", "Long Island")
data <- data %>% filter(island %in% keep)
data <- data %>% select(island, habitat, site, longitude, latitude, PC1, PC2, PC3, PC4)
# Rearrange the data
data <- data %>% gather_("variable", "score", variables)
# Function to compare sites within an island for a given variable
compare_sites <- function(data) {
data <- data %>%
group_by(site, habitat, longitude, latitude) %>%
nest()
ii <- 1:(nrow(data) - 1)
names(ii) <- ii
out <- map_dfr(ii, function(i) {
jj <- (i + 1):(nrow(data))
names(jj) <- jj
map_dfr(jj, function(j) {
res <- wilcox.test(data$data[[i]]$score, data$data[[j]]$score)
data.frame(U = res$statistic, pvalue = res$p.value)
}, .id = "j")
}, .id = "i")
out <- out %>% mutate_at(c("i", "j"), as.numeric)
out <- out %>% mutate(
habitat_i = map_chr(i, ~ as.character(data$habitat[.x])),
habitat_j = map_chr(j, ~ as.character(data$habitat[.x]))
)
out <- out %>% filter(habitat_i != habitat_j)
out <- out %>% mutate(
lon_i = map_dbl(i, ~ data$longitude[.x]),
lat_i = map_dbl(i, ~ data$latitude[.x]),
lon_j = map_dbl(j, ~ data$longitude[.x]),
lat_j = map_dbl(j, ~ data$latitude[.x])
)
out <- out %>% mutate(
distance = pmap_dbl(list(lon_i, lat_i, lon_j, lat_j), function(x1, y1, x2, y2) {
distm(x = c(x1, y1), y = c(x2, y2))
})
)
}
# Apply the function across islands and variables
res_wilcox <- data %>%
group_by(island, variable) %>%
nest() %>%
mutate(test = map(data, compare_sites)) %>%
select(-data) %>%
unnest(cols = c(test)) %>%
select(-i, -j)
# Read in the results of the post-hoc tests
res_posthoc <- read.csv("analyses/07-ANOVA/table_posthoc.csv", header = TRUE)
res_posthoc <- res_posthoc %>% filter(pvalue < 0.05)
res_posthoc <- res_posthoc %>% rename(island = "nesting")
res_postkw <- read.csv("analyses/07-ANOVA/table_postkw.csv", header = TRUE)
res_postkw <- res_postkw %>% filter(pvalue < 0.05)
# Combine parametric and nonparametric significant contrasts
res_posthoc <- res_posthoc %>% group_by(island, variable) %>% nest()
res_postkw <- res_postkw %>% group_by(island, variable) %>% nest()
res_postkw <- res_postkw %>% rename(data2 = "data")
res_posthoc <- res_posthoc %>%
full_join(res_postkw) %>%
mutate(data = map2(data, data2, ~ if (is.null(.y)) .x else .y)) %>%
select(-data2) %>%
unnest(cols = c(data)) %>%
rename(habitat_i = "contrast1", habitat_j = "contrast2")
# Keep the site comparisons for the significant contrasts only
res_posthoc <- res_posthoc %>% group_by(island, variable, habitat_i, habitat_j) %>% nest()
res_wilcox <- res_wilcox %>% group_by(island, variable, habitat_i, habitat_j) %>% nest()
res_wilcox <- res_wilcox %>% rename(data2 = "data")
res_wilcox <- res_wilcox %>%
right_join(res_posthoc) %>%
select(-data) %>%
unnest(cols = c(data2))
# Correct P-values for multiple testing and keep the most significant
res_wilcox <- res_wilcox %>% mutate(pvalue = p.adjust(pvalue, method = "BH"))
res_wilcox <- res_wilcox %>% filter(pvalue < 0.05)
# Plot P-values against distances
p <- ggplot(
data = res_wilcox,
aes(x = distance / 1000, y = pvalue, shape = island, fill = variable)
) +
geom_vline(xintercept = 0.5) +
geom_vline(xintercept = 1, lty = 2) +
geom_vline(xintercept = 5, lty = 3) +
geom_vline(xintercept = 10, lty = 4) +
geom_point(size = 5) +
scale_x_log10() +
scale_y_log10() +
theme_bw() +
xlab("Distance (km)") +
ylab("P-value") +
scale_fill_manual(values = rev(brewer.pal(length(variables), "YlOrRd"))) +
scale_shape_manual(values = 21:25) +
guides(fill = guide_legend(override.aes = list(shape = 21))) +
facet_grid(. ~ paste(habitat_i, habitat_j, sep = " vs ")) +
labs(fill = "Variable", shape = "Island") +
theme(legend.position = "bottom", legend.box = "vertical")
library(RColorBrewer)
# Plot P-values against distances
p <- ggplot(
data = res_wilcox,
aes(x = distance / 1000, y = pvalue, shape = island, fill = variable)
) +
geom_vline(xintercept = 0.5) +
geom_vline(xintercept = 1, lty = 2) +
geom_vline(xintercept = 5, lty = 3) +
geom_vline(xintercept = 10, lty = 4) +
geom_point(size = 5) +
scale_x_log10() +
scale_y_log10() +
theme_bw() +
xlab("Distance (km)") +
ylab("P-value") +
scale_fill_manual(values = rev(brewer.pal(length(variables), "YlOrRd"))) +
scale_shape_manual(values = 21:25) +
guides(fill = guide_legend(override.aes = list(shape = 21))) +
facet_grid(. ~ paste(habitat_i, habitat_j, sep = " vs ")) +
labs(fill = "Variable", shape = "Island") +
theme(legend.position = "bottom", legend.box = "vertical")
p
# Plot significant distances across islands
p2 <- p + aes(y = island) + scale_y_discrete() + ylab(NULL)
p2
# Assess the correlation between distance and P-value
res_spearman <- with(res_wilcox, cor.test(distance, pvalue, method = "spearman"))
res_spearman <- with(res_spearman, list(rho = round(estimate, 3), pvalue = round(p.value, 4)))
# Save table
t1 <- res_wilcox %>% select(-U, -pvalue)
t1 <- t1 %>% bind_cols(res_wilcox %>% ungroup %>% select(U, pvalue))
t1 <- t1 %>% add_signif()
head(t1)
head(t1)
t1_fname <- "analyses/10-distances/table_wilcoxon"
t1_names <- c("Island", "Variable", "Contrast", "", "Lon. 1", "Lat. 1", "Lon. 2", "Lat. 2", "Distance (m)", "$U$", "$P$")
save_table(t1, t1_fname, digits = c(0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 4), col.names = t1_names)
head(t1)
t1_names <- c("Island", "Variable", "Contrast", "", "Lon. 1", "Lat. 1", "Lon. 2", "Lat. 2", "Distance (m)", "$U$", "$P$", "")
save_table(t1, t1_fname, digits = c(0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 4), col.names = t1_names)
