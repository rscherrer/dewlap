template <- paste0("%.", sprintf("%sf", digits))
label <- sprintf(paste("<", template), threshold, digits)
rounded <- sprintf(template, round(pvalue, digits), digits)
ifelse(pvalue < threshold, label, rounded)
}
# Random forest results
read_csv("results/group_comparisons/machine_learning/PC/randomforest/summary.csv") %>%
mutate_signif() %>%
mutate(pvalue = round_pvalue(pvalue, digits = 4)) %>%
kable(
"latex",
col.names = c("Island", "$N$", "Score", "$P$", ""),
digits = c(0, 0, 3, 0, 0),
align = "lrrrl",
booktabs = TRUE,
linesep = "",
escape = FALSE
) %>%
cat(file = "ms/tables/randomforests.tex")
# LDA results
read_csv("results/group_comparisons/machine_learning/PC/lda/summary.csv") %>%
mutate_signif() %>%
mutate(pvalue = round_pvalue(pvalue, digits = 4)) %>%
kable(
"latex",
col.names = c(
"Island", "$N$", "Score", "$P$", ""
),
digits = c(0, 0, 3, 0, 0),
align = "lrrrl",
booktabs = TRUE,
linesep = "",
escape = FALSE
) %>%
cat(file = "ms/tables/ldas.tex")
# SVM results
read_csv("results/group_comparisons/machine_learning/PC/ksvm/summary.csv") %>%
mutate_signif() %>%
mutate(pvalue = round_pvalue(pvalue, digits = 4)) %>%
kable(
"latex",
col.names = c(
"Island", "$N$", "Score", "$P$", ""
),
digits = c(0, 0, 3, 0, 0),
align = "lrrrl",
booktabs = TRUE,
linesep = "",
escape = FALSE
) %>%
cat(file = "ms/tables/ksvms.tex")
# ANOVA table
read_csv("results/group_comparisons/anovas.csv") %>%
mutate_signif() %>%
mutate(pvalue = round_pvalue(pvalue, digits = 4)) %>%
kable(
"latex",
col.names = c(
"Island", "Variable", "AICc", "$\\Delta$AICc", "AICw", "Model",
"Log-lik.", "$\\chi^2$", "df", "$P$", ""
),
digits = c(0, 0, 2, 2, 3, 0, 2, 2, 0, 0, 0),
align = "llrrrlrrrrl",
booktabs = TRUE,
linesep = "",
escape = FALSE
) %>%
cat(file = "ms/tables/anova.tex")
# Spatial autocorrelation
read_csv("results/spatial_correlation/spatial_correlation.csv") %>%
mutate_signif() %>%
mutate(pvalue = round_pvalue(pvalue, digits = 3)) %>%
kable(
"latex",
col.names = c(
"Island", "$\\rho$", "$P$", ""
),
digits = c(0, 3, 0, 0),
align = "lrrl",
booktabs = TRUE,
linesep = "",
escape = FALSE
) %>%
cat(file = "ms/tables/autocorrelation.tex")
# Sample sizes
read_csv("metadata/counts.csv") %>%
rename(" " = "island") %>%
kable(
"latex",
booktabs = TRUE,
linesep = ""
) %>%
cat(file = "ms/tables/counts.tex")
# Site metadata
read_csv("metadata/sites.csv") %>%
kable(
"latex",
col.names = c(
"Island", "Longitude", "Latitude", "Habitat", paste0("PC", 1:4)
),
digits = c(0, 1, 1, 0, 3, 3, 3, 3),
booktabs = TRUE,
linesep = ""
) %>%
cat(file = "ms/tables/sites.tex")
# PCA explained variance
read_csv("results/pc_expvars/pc_expvars.csv") %>%
kable(
"latex",
col.names = c(
"Island", "Total", paste0("PC", 1:4)
),
digits = c(0, 3, 3, 3, 3, 3),
booktabs = TRUE,
linesep = ""
) %>%
cat(file = "ms/tables/pcavariances.tex")
# Tests of multivariate normality
read_csv("results/assumptions/multinorm.csv") %>%
mutate_signif() %>%
mutate(pvalue = round_pvalue(pvalue, digits = 4)) %>%
kable(
"latex",
col.names = c(
"Island", "Habitat", "Outliers", "$HZ$", "$P$", ""
),
digits = c(0, 0, 0, 3, 0, 0),
align = "llrrrl",
booktabs = TRUE,
linesep = "",
escape = FALSE
) %>%
cat(file = "ms/tables/multinorm.tex")
# Univariate normality
read_csv("results/assumptions/uninorm.csv") %>%
mutate_signif(col = "padj") %>%
mutate(padj = round_pvalue(padj, digits = 4)) %>%
kable(
"latex",
col.names = c(
"Island", "Variable", "$W$", "$P$", "$P_{adj}$", ""
),
digits = c(0, 0, 3, 4, 0, 0),
align = "llrrrl",
booktabs = TRUE,
linesep = "",
escape = FALSE
) %>%
cat(file = "ms/tables/normality.tex")
# Kruskal-Wallis tests
read_csv("results/group_comparisons/kruskalwallis.csv") %>%
mutate_signif() %>%
mutate(pvalue = round_pvalue(pvalue, digits = 4)) %>%
kable(
"latex",
col.names = c(
"Island", "Variable", "$\\chi^2$", "df", "$P$", ""
),
digits = c(0, 0, 2, 0, 0, 0),
align = "llrrrl",
booktabs = TRUE,
linesep = "",
escape = FALSE
) %>%
cat(file = "ms/tables/kruskal.tex")
rm(list = ls())
library(nmgc)
library(tidyverse)
library(ggridges)
library(ggiraphExtra)
library(broom)
library(heplots)
library(MVN)
library(assertthat)
library(rminer)
library(geosphere)
library(MuMIn)
library(nlme)
library(PMCMRplus)
library(RColorBrewer)
library(pairwiseAdonis)
library(scales)
library(vegan)
#### 1. Set-up ####
# Set plotting theme
theme_set(theme_classic())
# Graphical parameters
island_colors <- brewer.pal(8, "Set2")
island_colors <- c(island_colors, "darkgreen")
habitat_colors <- c("goldenrod", "forestgreen", "mediumseagreen")
# Global settings
pc_names <- paste0("PC", 1:4)
wpc_names <- paste0("w", pc_names)
wl <- 300:700
wl_names <- paste0("wl", wl)
# Whether to load machines already fitted to whole spectrum data
# (instead of rerunning the very lengthy classification)
read_fitted <- TRUE
#### 1. Set-up ####
# Set plotting theme
theme_set(theme_classic())
# Graphical parameters
island_colors <- brewer.pal(8, "Set2")
island_colors <- c(island_colors, "darkgreen")
habitat_colors <- c("goldenrod", "forestgreen", "mediumseagreen")
# Global settings
pc_names <- paste0("PC", 1:4)
wpc_names <- paste0("w", pc_names)
wl <- 300:700
wl_names <- paste0("wl", wl)
# Whether to load machines already fitted to whole spectrum data
# (instead of rerunning the very lengthy classification)
read_fitted <- TRUE
#### 2. Read reflectance data ####
# Read the data
D <- read_csv("data/reflectance.csv")
# Useful things to keep in mind
island_names <- unique(D$island)
habitat_names <- unique(D$habitat)
# Save sample sizes
with(D, table(island, habitat)) %>%
as_tibble() %>%
pivot_wider(names_from = habitat, values_from = n) %>%
write_csv("metadata/counts.csv")
#### 3. Principal component analysis ####
# Perform a PCA first because wavelengths are highly correlated
PCA <- prcomp(D[, wl_names], center = TRUE, scale = TRUE)
# How many PCs to retain?
cumsum(PCA$sdev / sum(PCA$sdev))
# Retain explained variance
expvars <- PCA$sdev[1:4] / sum(PCA$sdev)
# With four PCs we explain more than 90% of the variance
PCs <- PCA$x[, 1:4]
# Scale the principal components to unit variance (they are centered by constr)
PCs <- scale(PCs, scale = TRUE)
# Attach the matrix of principal components to the dataset
D <- cbind(D, PCs)
#### 6. Within-island principal component analysis ####
# Perform PCA within each island
D <- D %>%
group_by(island) %>%
nest() %>%
mutate(
# Within-island principal component analysis
PCA = map(data, ~ prcomp(.x[, wl_names], center = TRUE, scale = TRUE)),
# Extract rotated data
PCs = map(PCA, function(PCA) {
PCs <- as_tibble(scale(PCA$x[, 1:4], scale = TRUE))
colnames(PCs) <- paste0("w", colnames(PCs)) # label to recognize them
return(PCs)
})
)
# Extract the fitted within-island PCAs
wPCA <- D$PCA
names(wPCA) <- island_names
# Unnest the data frame
D <- D %>%
select(-PCA) %>%
unnest(cols = c(data, PCs))
# Now the dataset is complete
# saveRDS(D, "data.rds")
# Set specific colors for the retained PCs
wpc_colors <- hue_pal()(length(wpc_names))
names(wpc_colors) <- str_remove(wpc_names, "w")
# Make a table with the variance explained by each PC on each island
map(wPCA, ~ with(.x, sdev[1:4] / sum(sdev))) %>%
do.call("rbind", .) %>%
as_tibble(.name_repair = ) %>%
mutate(expvar = rowSums(.)) %>%
mutate(island = island_names) %>%
setNames(c(pc_names, "expvar", "island")) %>%
select(island, expvar, pc_names) %>%
write_csv("results/pc_expvars/pc_expvars.csv")
#### 6. Within-island principal component analysis ####
# Perform PCA within each island
D <- D %>%
group_by(island) %>%
nest() %>%
mutate(
# Within-island principal component analysis
PCA = map(data, ~ prcomp(.x[, wl_names], center = TRUE, scale = TRUE)),
# Extract rotated data
PCs = map(PCA, function(PCA) {
PCs <- as_tibble(scale(PCA$x[, 1:4], scale = TRUE))
colnames(PCs) <- paste0("w", colnames(PCs)) # label to recognize them
return(PCs)
})
)
# Extract the fitted within-island PCAs
wPCA <- D$PCA
names(wPCA) <- island_names
# Unnest the data frame
D <- D %>%
select(-PCA) %>%
unnest(cols = c(data, PCs))
# Now the dataset is complete
# saveRDS(D, "data.rds")
# Set specific colors for the retained PCs
wpc_colors <- hue_pal()(length(wpc_names))
names(wpc_colors) <- str_remove(wpc_names, "w")
rm(list = ls())
library(nmgc)
library(tidyverse)
library(ggridges)
library(ggiraphExtra)
library(broom)
library(heplots)
library(MVN)
library(assertthat)
library(rminer)
library(geosphere)
library(MuMIn)
library(nlme)
library(PMCMRplus)
library(RColorBrewer)
library(pairwiseAdonis)
library(scales)
library(vegan)
#### 1. Set-up ####
# Set plotting theme
theme_set(theme_classic())
# Graphical parameters
island_colors <- brewer.pal(8, "Set2")
island_colors <- c(island_colors, "darkgreen")
habitat_colors <- c("goldenrod", "forestgreen", "mediumseagreen")
# Global settings
pc_names <- paste0("PC", 1:4)
wpc_names <- paste0("w", pc_names)
wl <- 300:700
wl_names <- paste0("wl", wl)
# Whether to load machines already fitted to whole spectrum data
# (instead of rerunning the very lengthy classification)
read_fitted <- TRUE
#### 2. Read reflectance data ####
# Read the data
D <- read_csv("data/reflectance.csv")
# Useful things to keep in mind
island_names <- unique(D$island)
habitat_names <- unique(D$habitat)
# Save sample sizes
with(D, table(island, habitat)) %>%
as_tibble() %>%
pivot_wider(names_from = habitat, values_from = n) %>%
write_csv("metadata/counts.csv")
#### 3. Principal component analysis ####
# Perform a PCA first because wavelengths are highly correlated
PCA <- prcomp(D[, wl_names], center = TRUE, scale = TRUE)
# How many PCs to retain?
cumsum(PCA$sdev / sum(PCA$sdev))
# Retain explained variance
expvars <- PCA$sdev[1:4] / sum(PCA$sdev)
# With four PCs we explain more than 90% of the variance
PCs <- PCA$x[, 1:4]
# Scale the principal components to unit variance (they are centered by constr)
PCs <- scale(PCs, scale = TRUE)
# Attach the matrix of principal components to the dataset
D <- cbind(D, PCs)
#### 6. Within-island principal component analysis ####
# Perform PCA within each island
D <- D %>%
group_by(island) %>%
nest() %>%
mutate(
# Within-island principal component analysis
PCA = map(data, ~ prcomp(.x[, wl_names], center = TRUE, scale = TRUE)),
# Extract rotated data
PCs = map(PCA, function(PCA) {
PCs <- as_tibble(scale(PCA$x[, 1:4], scale = TRUE))
colnames(PCs) <- paste0("w", colnames(PCs)) # label to recognize them
return(PCs)
})
)
# Extract the fitted within-island PCAs
wPCA <- D$PCA
names(wPCA) <- island_names
# Unnest the data frame
D <- D %>%
select(-PCA) %>%
unnest(cols = c(data, PCs))
# Now the dataset is complete
# saveRDS(D, "data.rds")
# Set specific colors for the retained PCs
wpc_colors <- hue_pal()(length(wpc_names))
names(wpc_colors) <- str_remove(wpc_names, "w")
#### 6.4. Explained variance ####
# Make a table with the variance explained by each PC on each island
map(wPCA, ~ with(.x, sdev[1:4] / sum(sdev))) %>%
do.call("rbind", .) %>%
as_tibble(.name_repair = ) %>%
mutate(expvar = rowSums(.)) %>%
mutate(island = island_names) %>%
setNames(c(pc_names, "expvar", "island")) %>%
select(island, expvar, pc_names) %>%
write_csv("results/pc_expvars/pc_expvars.csv")
# Make a table with the variance explained by each PC on each island
map(wPCA, ~ with(.x, sdev[1:4] / sum(sdev))) %>%
do.call("rbind", .) %>%
as_tibble(.name_repair = ) %>%
mutate(expvar = rowSums(.)) %>%
mutate(island = island_names) %>%
setNames(c(pc_names, "expvar", "island")) %>%
select(island, expvar, pc_names) #%>%
PCA
PCA$sdev
PCA$sdev[1:4]
PCA$sdev %>% .[1:4]
PCA$sdev %>% .[1:4] / sum(.)
PCA$sdev %>% (.[1:4] / sum(.))
PCA$sdev %>% {.[1:4] / sum(.)}
with(PCA, sdev[1:4] / sum(sdev))
# Make a table with the variance explained by each PC on each island
map(wPCA, ~ with(.x, sdev[1:4] / sum(sdev))) %>%
do.call("rbind", .) %>%
as_tibble(.name_repair = ) %>%
mutate(expvar = rowSums(.)) %>%
mutate(island = island_names) %>%
setNames(c(pc_names, "expvar", "island")) %>%
select(island, expvar, pc_names) #%>%
pc_expvar <- with(PCA, sdev[1:4] / sum(sdev))
pc_expvar <- with(PCA, sdev[1:4] / sum(sdev))
names(pc_expvar) <- pc_names
pc_expvar
as.list(pc_expvar)
c(island = "All islands", expvar = sum(pc_expvar), as.list(pc_expvars))
c(island = "All islands", expvar = sum(pc_expvar), as.list(pc_expvar))
X %>% add_row(island)
# Make a table with the variance explained by each PC on each island
X <- map(wPCA, ~ with(.x, sdev[1:4] / sum(sdev))) %>%
do.call("rbind", .) %>%
as_tibble(.name_repair = ) %>%
mutate(expvar = rowSums(.)) %>%
mutate(island = island_names) %>%
setNames(c(pc_names, "expvar", "island")) %>%
select(island, expvar, pc_names)
new_row <- c(island = "All islands", expvar = sum(pc_expvar), as.list(pc_expvar))
X %>% add_row(!!!new_row)
# Make a table with the variance explained by each PC on each island
X <- map(wPCA, ~ with(.x, sdev[1:4] / sum(sdev))) %>%
do.call("rbind", .) %>%
as_tibble(.name_repair = ) %>%
mutate(expvar = rowSums(.)) %>%
mutate(island = island_names) %>%
setNames(c(pc_names, "expvar", "island")) %>%
select(island, expvar, pc_names)
# Record explained variance for the global PCA on all islands
pc_expvar <- with(PCA, sdev[1:4] / sum(sdev))
names(pc_expvar) <- pc_names
# Prepare extra row for all islands
new_row <- c(
island = "All islands",
expvar = sum(pc_expvar),
as.list(pc_expvar)
)
# Append extra row
X <- X %>% add_row(!!!new_row)
# Save the table
write_csv("results/pc_expvars/pc_expvars.csv")
X
# Save the table
write_csv(X, "results/pc_expvars/pc_expvars.csv")
rm(list = ls())
library(tidyverse)
library(knitr)
library(kableExtra)
rm(list = ls())
library(tidyverse)
library(knitr)
library(kableExtra)
#### 0. Accessory functions ####
# Function to add a significance column with asterisk symbols to a tibble
mutate_signif <- function(
D, col = "pvalue", levels = c(0.05, 0.01, 0.001), dropname = TRUE
) {
D <- D %>%
mutate(
.signif = ifelse(get(col) < levels[1], "*", ""),
.signif = ifelse(get(col) < levels[2], "**", .signif),
.signif = ifelse(get(col) < levels[3], "***", .signif)
)
if (dropname) D <- D %>% rename(" " = ".signif")
return(D)
}
# Round and format P-values
round_pvalue <- function(pvalue, digits = 4) {
threshold <- 1 / 10^digits
template <- paste0("%.", sprintf("%sf", digits))
label <- sprintf(paste("<", template), threshold, digits)
rounded <- sprintf(template, round(pvalue, digits), digits)
ifelse(pvalue < threshold, label, rounded)
}
# PCA explained variance
read_csv("results/pc_expvars/pc_expvars.csv") %>%
kable(
"latex",
col.names = c(
"Island", "Total", paste0("PC", 1:4)
),
digits = c(0, 3, 3, 3, 3, 3),
booktabs = TRUE,
linesep = ""
) %>%
cat(file = "ms/tables/pcavariances.tex")
read_csv("results/pc_expvars/pc_expvars.csv") %>%
kable(
"latex",
col.names = c(
"Island", "Total", paste0("PC", 1:4)
),
digits = c(0, 3, 3, 3, 3, 3),
booktabs = TRUE,
linesep = ""
)
